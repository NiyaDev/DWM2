
// 
// My brain is small, this is to help me understand
// 



[rP1]    = $FF00;
[rIF]    = $FF0F;
[rNR50]  = $FF24;
[rNR51]  = $FF25;
[rNR52]  = $FF26;
[rSCY]   = $FF42;
[rSCX]   = $FF43;
[rBGP]   = $FF47;  
[rVBK]   = $FF4F; // 
[rRP]    = $FF56; // CGB Mode Only
[rSVBK]  = $FF70; // 


P1F_5        = %00100000 // P15 out port, set to 0 to get buttons
P1F_4        = %00010000 // P14 out port, set to 0 to get dpad
P1F_3        = %00001000 // P13 in port
P1F_2        = %00000100 // P12 in port
P1F_1        = %00000010 // P11 in port
P1F_0        = %00000001 // P10 in port

P1F_GET_DPAD = P1F_5
P1F_GET_BTN  = P1F_4
P1F_GET_NONE = P1F_4 | P1F_5

[rRAMG]  = $0100;
[rROMB0] = $2100;
[rROMB1] = $3100;
[rRAMB]  = $4100;


[$C0C0]  = $C0C0;
//	Start = $00
[$C0C1]  = $C0C1;
//	Start = $00
[$C0D8]  = $C0D8;
//	Start = $00
[$C0D9]  = $C0D9;
//	Start = $00
[$C47C]  = $C47C;
//	Start    = $20
//	Start    = $02
//	Start    = $03
//	Start    = $04
//	Start    = $05
//	Start    = $06
//	Start    = $07
//	Start    = $08
//	Start    = $09
//	Start    = $18
//	Start    = $10
//	Start    = $19
//	Start    = $14
//	Start    = $00
//  FUN_0705 = $0C
//  FUN_05E3 = $0B
//  FUN_05E3 = $0A
[$C47F]  = $C47F;
//  FUN_ROM31_5040 
[$C51F]  = $C51F;
//	Start = $00
[$C520]  = $C520;
//	Start = $00
[$C523]  = $C523;
//	Start = $FF
[$C524]  = $C524;
//	Start = $01
//	Start = $00
//	Start = $01
[IsGBC]  = $C525;
[$C52B]  = $C52B;
//	Start = $00
[$C52F]  = $C52F;
//	Start = $00
[$C530]  = $C530;
//	Start = $00
[$C56C]  = $C56C;
[$C586]  = $C586;
//	Start = $00
[$C58A]  = $C58A;
[$C5DB]  = $C5DB;
//	Start = $05
[$C5DC]  = $C5DC;
//	Start = $00
[$C5DD]  = $C5DD;
//	Start = $00
[$C5DE]  = $C5DE;
//	Start = $00
[$C5DF]  = $C5DF;
//	Start = $00
[$C5E0]  = $C5E0;
//	Start = $00
[$C5EC]  = $C5EC;
[$C5ED]  = $C5ED;
//	Start = $00
[$C5EE]  = $C5EE;
//	Start = $00
[$C5F0]  = $C5F0;
//	Start = $00
[$C5F1]  = $C5F1;
//	Start = $00
[$C60A]  = $C60A;
//	Start = $FF
[$C60B]  = $C60B;
//	Start = $FF
[$DD09]  = $DD09;
//  FUN_3290 = $00;
[$DD12]  = $DD12;
//  FUN_32DB = $00;
[$DD13]  = $DD13;
//  FUN_32DB = $00;
[$DD14]  = $DD14;
//  FUN_32DB = $00;



EntryPoint:
	jp Start

Start :: proc() {

	if A == $11 do [IsGBC] = true;
	else        do [IsGBC] = false;

	di;
	SP = $DFFF;

	SetInterrupts();
	MemInitialization();
	CopyDMATransfer();

	Memset(0, 7168, $8000);

	if [IsGBC] == true {
		[rVBK] = 1;
		Memset(0, 2048, $9800);
		[rVBK] = 0;
	}

	[$C5DB] = 5;
	[$C5DC] = 0;
	[$C5DD] = 0;
	[$C5DE] = 0;

	[rRAMB]  = 0;  //
	[rRAMG]  = 0;  // ROM Bank 1
	[rROMB0] = 1;  //  selected
	[rROMB1] = 0;  //

	[$C524] = 1;
	[$C60A] = 255;
	[$C60B] = 255;

	FUN_3290();

	[$C58C] = 0;


	if [IsGBC] {
		[rVBK]  = 0;
		[rSVBK] = 0;
		[rRP]   = 0;

		FUN_ROM2_42FA();
	} else {
		if FUN_05E2() {
			Wait1750_X(12);

			[$C47C] = 20;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 2;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 3;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 4;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 5;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 6;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 7;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 8;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 9;
			FUN_ROM31_5040();
			Wait7000();

			FUN_0705(12, 2048, $446C, 23);
			Wait7000();

			FUN_06A8($0D, $17, $44, $8C);
			Wait7000();

			[$C47C] = 18;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 10;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 19;
			FUN_ROM31_5040();
			Wait7000();

			[$C47C] = 14;
			FUN_ROM31_5040();
			Wait7000();

			[$C524] = 1;
			[$C523] = 255;
			[$C51F] = 0;
			[$C520] = 0;
		}
	}

	[$C524] = 0;

	ei;

	for {
		VRAMClear();
		clear_work_start();
		FUN_0B7F();
		FUN_0B9B();
		FUN_0DCA();

		[$C586] = 0;
		[$C52B] = 0;
		[$C52F] = 0;
		[$C530] = 0;
		FUN_0355();

		[$C5DF]	= 0;
		[$C5E0]	= 0;
		[$C5EE]	= 0;
		[$C0C0]	= 0;
		[$C0C1]	= 0;
		[$C0D8]	= 0;
		[$C0D9]	= 0;
		[$C5ED]	= 0;
		[$C5F0]	= 0;
		[$C5F1]	= 0;

		[$FFB9] = 0;
		[$FFB9] = 128;

		[$C58D] = 0;
		[$C58E] = 0;

		[$C604] = 0;
		[$C605] = 0;
		[$C606] = 0;
		[$C607] = 0;

		for [$C5DF] == 0 {
			if [$C58A] == 0 do FUN_095B();

			halt;

			if [$C5DF] == 0           do continue;
			if [$C56C] == 0           do break;
			if bit(7, [$C56C]) == 128 do continue;
			else                      do break;
		}

		di;

		SetInterrupts();
		Wait7000();

		[$C47C] = 0;
		FUN_ROM23_5040();

		Wait7000();
	}
}


SECTION "CopyDMATransfer", ROM0[$0080]
// Copies DMA transfer function from 0x008E to high memory
CopyDMATransfer :: proc() {
	C  = $80;
	B  = $0A;
	HL = $008E;
	
	for B != 0 {
		[$FF00+C] = [HL];
		HL += 1;
		C  += 1;
		B  -= 1;
	}
}
ROMDMA: db  $3E, $C0, $E0, $46, $3E, $28, $3D, $20, $FD, $C9;

SECTION "05E2", ROM0[$05E2]
// FUN_05E2 ()
FUN_05E2 :: proc() -> bool {

	[$C47C] = $0B;
	FUN_ROM31_5040();

	Wait7000();

	if [rP1] & 3 == 3 {
		[rP1] = P1F_GET_DPAD;
		[rP1] = P1F_GET_NONE;
		[rP1] = P1F_GET_BTN;
		[rP1] = P1F_GET_NONE;

		if [rP1] & 3 == 3 {

			[$C47C] = $0A;
			FUN_ROM31_5040();

			Wait7000();

			return false;
		}
	}

	[$C47C] = $0A;
	FUN_ROM31_5040();

	Wait7000();

	return true;
}

SECTION "0705", ROM0[$0705]
// FUN_0705 (A: value, BC: counter, DE: ptr, H: bank)
FUN_0705 :: proc(A: value, BC: counter, DE: ptr, H: bank) {
	
	// Sets variable to input
	[$C47C] = A;

	if [$C524] == 0 do return;


	{ HL, BC
		DisableLCD();
		FUN_0B9B();

		// Sets the screen to 0,0
		[rSCX] = $00;
		[rSCY] = $00;
		// Pallette: Black, Dark gray,Light gray, White 
		[rBGP] = $E4;
	}

	// Grabs ROM bank
	A = [rRAMB];
	{ AF
		// Sets from bank to input
		{ BC
			[rROMB0] = bank;
		}

		// Copies data from DE to [$8800] VRAM
		HL = $8800;
		for counter != 0 {
			[HL] = [DE];
			HL  += 1;
			DE  += 1;
			BC  -= 1;
		}

		// Puts an incremented A into every $14 starting at [$9800]VRAM
		HL = $9800;
		DE = $000C;
		A  = $80;
		C  = $0D;
		for C != 0 {
			B = $14;
			for B != 0 {
				[HL] = A;
				HL  += 1;
				A   += 1;
				B   -= 1;
			}
			HL += DE;
			C  -=  1;
		}

		[rLCDC] = $81;
		[$C5EC] = $81;

		Wait1750_X(5);
		FUN_ROM31_5040();
		DisableLCD();
	}
	[rROMB0] = A;
}

SECTION "SetInterrupts", ROM0[$078D]
// Sets enabled interrupts, then disables LCD
SetInterrupts :: proc() {
	[rIF]  = 0;
	[rIF] &= $E2;

	DisableLCD();
}
DisableLCD :: proc() {
	if bit(7, [$FF40]) == 0 do return;

	while [rLY] != 0 {}

	reset(7, [$FF40]);
	reset(7, [$C5EC]);
}

SECTION "MemInit", ROM0[$08D0]
// Initializes various parts of both console RAM and Cart RAM
MemInitialization :: proc() {
	if [IsGBC] != 0 {
		[rVBK]   = 0;
		[rSVBK]  = 0;
		[rHDMA1] = 0;
		[rHDMA2] = 0;
		[rHDMA3] = 0;
		[rHDMA4] = 0;
		[rHDMA5] = 0;
		[rBCPS]  = 0;
		[rOCPS]  = 0;
	}

	Memset(0, $1E00, $C000);
	Memset(0, $0074, $FF8A);

	[rRAMG] = 10;
	[rRAMB] =  2;

	Memset(0, $2000, $A000);
	[rRAMB] = 0;
	Memset(0, $2000, $A000);
	[rRAMG] = 0;
}

SECTION "Memset", ROM0[$0949]
// Sets memory at pointer HL to Value a BC times
Memset :: proc(A: value, BC: counter, HL: pointer) {
	for counter != 0 {
		[pointer] = value;
		pointer += 1;
		counter -= 1;
	}
}

SECTION "FUN_095B", ROM0[$095B]
// 
FUN_095B :: proc() {
	{ HL
		A        = ([$C5E8] + 1) & $7F;
		[$C5E8]  = A;
		A       += $73;
		L        = A;

		if L > $FF do H += 1;

		[$C5E7] = [HL];
	}
}

SECTION "FUN_0B7F", ROM0[$0B7F]
// Sets three bytes in seperate locations to $D2,$D2,$E2
FUN_0B7F :: proc() {
	[$C5E9] = $D2;
	[$C5EA] = $D2;
	[$C5EB] = $E2;

	[$D040] = $D2;
	[$D041] = $D2;
	[$D042] = $E2;
}

SECTION "clear_8_hram", ROM0[$0B9B]
// Sets three bytes in seperate locations to $D2,$D2,$E2
clear_8_hram :: proc() {
	clear_4_hram(0, $FFA1);
	clear_4_hram(0, $FFA5);
}
clear_4_hram :: proc(A: val, HL: ptr) {
	[HL+0] = val;
	[HL+1] = val;
	[HL+2] = val;
	[HL+3] = val;
}

SECTION "clear_work_start", ROM0[$0BA7]
// Clears the first 160 bytes of work RAM
clear_work_start :: proc() {
	[$ffB1] = 0;

	HL = $C000;
	B  = $A0;
	for B != 0 {
		[HL]  = 0;
		HL   += 1;
		B    -= 1;
	}
}

SECTION "FUN_0DCA", ROM0[$0DCA]
// 
FUN_0DCA :: proc() {
	[$C56F] = [$C5E9];
	[$C570] = [$C5EA];
	[$C571] = [$C5EB];

	[$C572] = 0;
	[$C573] = 0;
	[$C574] = 0;
	[$C575] = 0;
	[$C576] = 0;

	[$C56C] = 0;
	[$C56D] = $07;
	[$C56E] = $1f;
}

SECTION "FUN_3290", ROM0[$3290]
// Preps audio then does some audio clearing
FUN_3290 :: proc() {
	// Sets some variables
	FUN_32DB(0,0);
	[rNR52] = $80;
	[rNR51] = $00;
	[$DD09] = $00;
	[rNR50] = $77;

	// Insert $FFFF every $22 from $DC00-$DCCC
	HL = $DC00;              
	DE = $0020;
	B  = $06;
	for B != 0 {
		[Hl+] = $FF;
		[HL+] = $FF;
		HL   += $0020;
		B    -= $01;
	}

	// Clears $48 bytes from [$DCC0]-[$DD08]
	HL = $DCC0;
	B  = $48
	for i != 0 {
		[HL] = $00;
		HL  += $01;
		B   -= $01;
	}

	// Sets some variables
	[$DD15] = 0;
	[$DD19] = 0;
}
FUN_32C6 :: proc() {
	[$DD15] = 0;
	[$DD09] = 0;
}
FUN_32D1 :: proc() {
	[$DD15] = 4;
	[$DD09] = 4;
}
FUN_32DB :: proc(B: val1, C: val2) {
	[$DD12] = B;
	[$DD13] = C;
	[$DD14] = 0;
}

SECTION "5040", ROMX[$5040], BANK[31]
// I still have no idea about this function
// All it really does is read/write the joypad a bunch of times
FUN_ROM31_5040 :: proc() {
	if ![$C524] do return;

	if [$C47C] != $FF {
		// Get pointer from ROM
		L   = [$C47C];
		HL  = ([$C47C] * 2) + $5094;
		DE  = [HL];
		HL  = DE;
	} else do HL = $C47F;

	if [HL] & $07 == 0 do return;

	B = [HL] & 7;
	C = $00;

	for {
		{ BC
			[rP1] = $00;
			[rP1] = P1F_GET_NONE;

			B = $10;
			// Goes through the next 16 bytes and tests each one
			for B != 0 {
				E   = $08;
				D   = [HL];
				HL += 1;
				// Goes through every bit in D and sets [rP1] to btn or dpad depending
				for E != 0 {
					if !bit(0, D) do A = P1F_GET_DPAD;
					else          do A = P1F_GET_BTN;

					[rP1] = A;
					[rP1] = $00;

					D  = D << 1;
					E -= 1;
				}
				B -= 1;
			}

			[rP1] = P1F_GET_DPAD;
			[rP1] = P1F_GET_NONE;
		}

		B -= 1;
		if B == 0 do return;
	}
}